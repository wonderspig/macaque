/**
题目:
  有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。
  现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。
  示例 1:
  输入: 
  bits = [1, 0, 0]
  输出: True
  解释: 
  唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
  示例 2:
  输入: 
  bits = [1, 1, 1, 0]
  输出: False
  解释: 
  唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。
思路:
  1. 存在多种可能情况的探测,适合使用递归
  2. 当然可以通过观察 发现其内在规律:从后向前 从倒数第二位置 连续1个数的奇偶性来判断
效果:
  执行用时：4 ms, 在所有 Go 提交中击败了88.04%的用户
  内存消耗：2.8 MB, 在所有 Go 提交中击败了5.56%的用户
*/
func isOneBitCharacter(bits []int) bool {
    if len(bits) == 0{
        return false
    }
    if len(bits) == 1 && bits[0] == 0{
        return true
    }
    if bits[0] == 0{
        return isOneBitCharacter(bits[1:])
    }else{
        return isOneBitCharacter(bits[2:])
    }
}
